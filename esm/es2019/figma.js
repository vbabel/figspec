// This module defines data types used in Figma API.
// The purpose of these type definition is for our rendering and inspector
// panel only. Properties not used in those feature would be omitted.
function isColor(x) {
  return (
    !!x &&
    typeof x === "object" &&
    "r" in x &&
    Number.isFinite(x.r) &&
    "g" in x &&
    Number.isFinite(x.g) &&
    "b" in x &&
    Number.isFinite(x.b) &&
    "a" in x &&
    Number.isFinite(x.a)
  );
}
function isBlendMode(x) {
  switch (x) {
    case "PASS_THROUGH":
    case "NORMAL":
    case "DARKEN":
    case "MULTIPLY":
    case "LINEAR_BURN":
    case "COLOR_BURN":
    case "LIGHTEN":
    case "SCREEN":
    case "LINEAR_DODGE":
    case "COLOR_DODGE":
    case "OVERLAY":
    case "SOFT_LIGHT":
    case "HARD_LIGHT":
    case "DIFFERENCE":
    case "EXCLUSION":
    case "HUE":
    case "SATURATION":
    case "COLOR":
    case "LUMINOSITY":
      return true;
    default:
      return false;
  }
}
function isVector(x) {
  return (
    !!x &&
    typeof x === "object" &&
    "x" in x &&
    Number.isFinite(x.x) &&
    "y" in x &&
    Number.isFinite(x.y)
  );
}
function isEffect(x) {
  return (
    !!x &&
    typeof x === "object" &&
    "type" in x &&
    typeof x.type === "string" &&
    "visible" in x &&
    typeof x.visible === "boolean" &&
    "radius" in x &&
    typeof x.radius === "number"
  );
}
export function isShadowEffect(x) {
  if (x.type !== "INNER_SHADOW" && x.type !== "DROP_SHADOW") {
    return false;
  }
  return (
    "color" in x &&
    isColor(x.color) &&
    "blendMode" in x &&
    isBlendMode(x.blendMode) &&
    "offset" in x &&
    isVector(x.offset) &&
    (!("spread" in x) || Number.isFinite(x.spread)) &&
    (!("showShadowBehindNode" in x) ||
      typeof x.showShadowBehindNode === "boolean")
  );
}
function isRectangle(x) {
  return (
    !!x &&
    typeof x === "object" &&
    "x" in x &&
    typeof x.x === "number" &&
    "y" in x &&
    typeof x.y === "number" &&
    "width" in x &&
    typeof x.width === "number" &&
    "height" in x &&
    typeof x.height === "number"
  );
}
function isColorStop(x) {
  return (
    !!x &&
    typeof x === "object" &&
    "position" in x &&
    typeof x.position === "number" &&
    "color" in x &&
    isColor(x.color)
  );
}
function isPaintGlobalProperties(x) {
  return (
    !!x &&
    typeof x === "object" &&
    "type" in x &&
    typeof x.type === "string" &&
    (!("visible" in x) || typeof x.visible === "boolean") &&
    (!("opacity" in x) || typeof x.opacity === "number") &&
    "blendMode" in x &&
    isBlendMode(x.blendMode)
  );
}
function isSolidPaint(x) {
  return x.type === "SOLID" && "color" in x && isColor(x.color);
}
const GRADIENT_TYPE_PATTERN = /^GRADIENT_(LINEAR|RADIAL|ANGULAR|DIAMOND)$/;
function isGradientPaint(x) {
  return (
    GRADIENT_TYPE_PATTERN.test(x.type) &&
    "gradientHandlePositions" in x &&
    Array.isArray(x.gradientHandlePositions) &&
    x.gradientHandlePositions.every(isVector) &&
    "gradientStops" in x &&
    Array.isArray(x.gradientStops) &&
    x.gradientStops.every(isColorStop)
  );
}
function isImagePaint(x) {
  if (!("scaleMode" in x)) {
    return false;
  }
  switch (x.scaleMode) {
    case "FILL":
    case "FIT":
    case "TILE":
    case "STRETCH":
      return true;
    default:
      return false;
  }
}
function isOtherPaint(x) {
  switch (x.type) {
    case "VIDEO":
    case "EMOJI":
      return true;
    default:
      return false;
  }
}
function isPaint(x) {
  if (!isPaintGlobalProperties(x)) {
    return false;
  }
  return (
    isSolidPaint(x) || isGradientPaint(x) || isImagePaint(x) || isOtherPaint(x)
  );
}
export function hasBackgroundColor(node) {
  return "backgroundColor" in node && isColor(node.backgroundColor);
}
export function hasFills(node) {
  return (
    "fills" in node && Array.isArray(node.fills) && node.fills.every(isPaint)
  );
}
export function hasStroke(node) {
  if (!("strokeAlign" in node)) {
    return false;
  }
  switch (node.strokeAlign) {
    case "INSIDE":
    case "OUTSIDE":
    case "CENTER":
      break;
    default:
      return false;
  }
  return (
    "strokes" in node &&
    Array.isArray(node.strokes) &&
    node.strokes.every(isPaint) &&
    "strokeWeight" in node &&
    Number.isFinite(node.strokeWeight) &&
    (!("strokeDashes" in node) ||
      (Array.isArray(node.strokeDashes) &&
        node.strokeDashes.every(Number.isFinite)))
  );
}
export function hasEffects(node) {
  return (
    "effects" in node &&
    Array.isArray(node.effects) &&
    node.effects.every(isEffect)
  );
}
export function hasCharacters(node) {
  return "characters" in node && typeof node.characters === "string";
}
export function hasTypeStyle(node) {
  return (
    "style" in node &&
    typeof node.style === "object" &&
    !!node.style &&
    "fontFamily" in node.style &&
    typeof node.style.fontFamily === "string"
  );
}
export function hasBoundingBox(node) {
  return (
    "absoluteBoundingBox" in node &&
    isRectangle(node.absoluteBoundingBox) &&
    (!("absoluteRenderBounds" in node) ||
      isRectangle(node.absoluteRenderBounds))
  );
}
export function hasPadding(node) {
  return (
    "paddingTop" in node &&
    Number.isFinite(node.paddingTop) &&
    "paddingRight" in node &&
    Number.isFinite(node.paddingRight) &&
    "paddingBottom" in node &&
    Number.isFinite(node.paddingBottom) &&
    "paddingLeft" in node &&
    Number.isFinite(node.paddingLeft)
  );
}
export function hasLegacyPadding(node) {
  return (
    "horizontalPadding" in node &&
    Number.isFinite(node.horizontalPadding) &&
    "verticalPadding" in node &&
    Number.isFinite(node.verticalPadding)
  );
}
export function hasChildren(node) {
  return (
    "children" in node &&
    Array.isArray(node.children) &&
    node.children.every(isNode)
  );
}
export function hasRadius(node) {
  return "cornerRadius" in node && typeof node.cornerRadius === "number";
}
export function hasRadii(node) {
  return (
    "rectangleCornerRadii" in node &&
    Array.isArray(node.rectangleCornerRadii) &&
    node.rectangleCornerRadii.length === 4
  );
}
export function isNode(x) {
  return (
    typeof x === "object" &&
    !!x &&
    "id" in x &&
    typeof x.id === "string" &&
    "name" in x &&
    typeof x.name === "string" &&
    (!("visible" in x) || typeof x.visible === "boolean") &&
    "type" in x &&
    typeof x.type === "string"
  );
}
/**
 * Walk over the node and its descendants.
 * Iterator is superior to the common callback-style walk function:
 * - Ability to abort the traverse with standard language feature (return, break)
 * - No implicit call timing convention - TypeScript's poor inference engine completely
 *   ignores assignments even if the callback function will be called immediately.
 *   The inference system is built upon unrealistic illusion.
 *   https://github.com/microsoft/TypeScript/issues/9998
 * - (subjective) `for ~ of` over iterator is way more readable and easier to grasp than
 *   function invocation with unknown callback. When will the callback be invoked?
 *   What will happen when the callback function returned something?
 *
 * @param node - The root node to start traversing from. This function returns this parameter as a result at the very first.
 * @example
 * for (const node of walk(root)) {
 *   console.log(node.id)
 * }
 */
export function* walk(node) {
  yield node;
  if (hasChildren(node)) {
    for (const child of node.children) {
      for (const iter of walk(child)) {
        yield iter;
      }
    }
  }
}
function isCanvas(node) {
  return (
    node.type === "CANVAS" && hasChildren(node) && hasBackgroundColor(node)
  );
}
/**
 * Returns an iterator of CANVAS nodes.
 */
export function* getCanvases(node) {
  if (isCanvas(node)) {
    yield node;
    // CANVAS cannot be nested, so safe to quit lookup
    return;
  }
  if (!hasChildren(node)) {
    return;
  }
  for (const child of node.children) {
    for (const iter of getCanvases(child)) {
      yield iter;
    }
  }
}
