import { effect, Signal } from "./signal.js";
/**
 * Set or remove an attribute.
 *
 * @param name - An attribute name.
 * @param value - `string` is set as-is. `boolean` follows HTML's boolean attribute semantics:
 *                `true` sets an empty string and `false` removes the attribute itself.
 */
export function attr(name, value) {
  return (el) => {
    if (value instanceof Signal) {
      effect(() => {
        const v = value.get();
        if (typeof v === "string") {
          el.setAttribute(name, v);
        } else if (v === true) {
          el.setAttribute(name, "");
        } else {
          el.removeAttribute(name);
        }
      });
    } else if (typeof value === "string") {
      el.setAttribute(name, value);
    } else if (value === true) {
      el.setAttribute(name, "");
    }
  };
}
/**
 * Assign a value to the property.
 */
export function prop(key, value) {
  return (el) => {
    if (value instanceof Signal) {
      effect(() => {
        el[key] = value.get();
      });
    } else {
      el[key] = value;
    }
  };
}
/**
 * Invoke the given callback after `requestAnimationFrame`.
 *
 * Provided as an escape-hatch for DOM quirks.
 *
 * @example
 * el("select", [
 *   raf(compute(() => (el) => {
 *     el.value = value.get();
 *   }))
 * ])
 */
export function raf(f) {
  return (el) => {
    requestAnimationFrame(() => {
      if (f instanceof Signal) {
        effect(() => {
          f.get()(el);
        });
      } else {
        f(el);
      }
    });
  };
}
/**
 * Set element's inline style.
 *
 * This is not same as `HTMLElement.style.foo`: under the hood, `CSSStyleDeclaration.setProperty` is used.
 * Hence, property name must be hyphen-cased.
 * Property value can be one of `string`, `null`, or `undefined`.
 *
 * - `string`    ... Sets the value to the property.
 * - `null`      ... Removes the property from stylesheet.
 * - `undefined` ... Does nothing.
 *
 * When used with Signal, use of `undefined` would lead to confusing behavor.
 *
 * ```ts
 * const border = signal<string | undefined>("1px solid #000");
 * style({ border });
 * border.set(undefined)
 * ```
 *
 * In the above code, setting `undefined` does nothing: the actual border property's value
 * is still `1px solid #000`. In order to avoid these kind of surprising situation, use of
 * `string` is always recommended.
 *
 * ```ts
 * const border = signal("1px solid #000");
 * style({ border });
 * border.set("none")
 * ```
 */
export function style(style) {
  return (el) => {
    for (const key in style) {
      const value = style[key];
      if (typeof value === "string") {
        el.style.setProperty(key, value);
      } else if (value instanceof Signal) {
        effect(() => {
          const v = value.get();
          if (typeof v === "string") {
            el.style.setProperty(key, v);
          } else if (v === null) {
            el.style.removeProperty(key);
          }
        });
      } else if (value === null) {
        el.style.removeProperty(key);
      }
    }
  };
}
/**
 * Sets a class or a list of classes.
 *
 * This function does not accept Signal.
 * Use `data-*` attribute or property for dynamic values.
 */
export function className(...value) {
  return (el) => {
    el.classList.add(...value);
  };
}
export function on(eventName, callback, options) {
  return (el) => {
    // @ts-expect-error: This is a limit coming from TS being dirty hack illusion.
    el.addEventListener(eventName, callback, options);
  };
}
function appendChild(parent, child) {
  if (child === null || typeof child === "undefined") {
    return;
  }
  if (typeof child === "string") {
    parent.appendChild(document.createTextNode(child));
  } else {
    parent.appendChild(child);
  }
}
// `el` is parameterized because a function to create an `Element` depends on Element types. (sub-types?)
function provision(el, attrs, children) {
  for (const attr of attrs) {
    attr(el);
  }
  for (const child of children) {
    if (child instanceof Signal) {
      const start = document.createTextNode("");
      const end = document.createTextNode("");
      el.appendChild(start);
      el.appendChild(end);
      effect(() => {
        const childNode = child.get();
        const prevNode =
          !start.nextSibling || start.nextSibling === end
            ? null
            : start.nextSibling;
        if (childNode === null || typeof childNode === "undefined") {
          if (prevNode) {
            prevNode.remove();
          }
          return;
        }
        const node =
          typeof childNode === "string"
            ? document.createTextNode(childNode)
            : childNode;
        if (prevNode) {
          prevNode.replaceWith(node);
        } else {
          el.insertBefore(node, end);
        }
      });
    } else {
      appendChild(el, child);
    }
  }
  return el;
}
/**
 * Create a HTML element.
 */
export function el(tagName, attrs = [], children = []) {
  return provision(document.createElement(tagName), attrs, children);
}
/**
 * Create a SVG element.
 *
 * You don't need to set `xmlns` attribute for elements created by this function.
 */
export function svg(tagName, attrs = [], children = []) {
  return provision(
    document.createElementNS("http://www.w3.org/2000/svg", tagName),
    attrs,
    children,
  );
}
