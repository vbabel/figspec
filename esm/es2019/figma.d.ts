/**
 * https://www.figma.com/developers/api#color-type
 */
export interface Color {
  readonly r: number;
  readonly g: number;
  readonly b: number;
  readonly a: number;
}
/**
 * https://www.figma.com/developers/api#blendmode-type
 */
export type BlendMode =
  | "PASS_THROUGH"
  | "NORMAL"
  | "DARKEN"
  | "MULTIPLY"
  | "LINEAR_BURN"
  | "COLOR_BURN"
  | "LIGHTEN"
  | "SCREEN"
  | "LINEAR_DODGE"
  | "COLOR_DODGE"
  | "OVERLAY"
  | "SOFT_LIGHT"
  | "HARD_LIGHT"
  | "DIFFERENCE"
  | "EXCLUSION"
  | "HUE"
  | "SATURATION"
  | "COLOR"
  | "LUMINOSITY";
/**
 * https://www.figma.com/developers/api#vector-type
 */
export interface Vector {
  readonly x: number;
  readonly y: number;
}
export interface Effect {
  readonly type: "LAYER_BLUR" | "BACKGROUND_BLUR" | string;
  readonly visible: boolean;
  readonly radius: number;
}
export interface ShadowEffect {
  readonly type: "INNER_SHADOW" | "DROP_SHADOW";
  readonly visible: boolean;
  readonly radius: number;
  readonly color: Color;
  readonly blendMode: BlendMode;
  readonly offset: Vector;
  readonly spread?: number;
  readonly showShadowBehindNode?: boolean;
}
export declare function isShadowEffect(x: Effect): x is ShadowEffect;
/**
 * https://www.figma.com/developers/api#rectangle-type
 */
export interface Rectangle {
  readonly x: number;
  readonly y: number;
  readonly width: number;
  readonly height: number;
}
/**
 * https://www.figma.com/developers/api#colorstop-type
 */
export interface ColorStop {
  readonly position: number;
  readonly color: Color;
}
export interface PaintGlobalProperties {
  readonly type: string;
  /**
   * @default true
   */
  readonly visible?: boolean;
  /**
   * @default 1
   */
  readonly opacity?: number;
  readonly blendMode: BlendMode;
}
export interface SolidPaint extends PaintGlobalProperties {
  readonly type: "SOLID";
  readonly color: Color;
}
export interface GradientPaint extends PaintGlobalProperties {
  readonly type:
    | "GRADIENT_LINEAR"
    | "GRADIENT_RADIAL"
    | "GRADIENT_ANGULAR"
    | "GRADIENT_DIAMOND";
  readonly gradientHandlePositions: readonly [Vector, Vector, Vector];
  readonly gradientStops: readonly ColorStop[];
}
export interface ImagePaint extends PaintGlobalProperties {
  readonly type: "IMAGE";
  readonly scaleMode: "FILL" | "FIT" | "TILE" | "STRETCH";
}
export interface OtherPaint extends PaintGlobalProperties {
  readonly type: "VIDEO" | "EMOJI";
}
/**
 * https://www.figma.com/developers/api#paint-type
 */
export type Paint = SolidPaint | GradientPaint | ImagePaint | OtherPaint;
interface HasBackgroundColor {
  /**
   * Background color of the canvas.
   */
  backgroundColor: Color;
}
export declare function hasBackgroundColor(
  node: Node,
): node is Node & HasBackgroundColor;
interface HasFills {
  /**
   * @default []
   */
  readonly fills: Paint[];
}
export declare function hasFills(node: Node): node is Node & HasFills;
interface HasStroke {
  /**
   * @default []
   */
  readonly strokes: readonly Paint[];
  readonly strokeWeight: number;
  readonly strokeAlign: "INSIDE" | "OUTSIDE" | "CENTER";
  /**
   * @default []
   */
  readonly strokeDashes?: readonly number[];
}
export declare function hasStroke(node: Node): node is Node & HasStroke;
export interface HasEffects {
  effects: readonly (Effect | ShadowEffect)[];
}
export declare function hasEffects(node: Node): node is Node & HasEffects;
interface HasCharacters {
  readonly characters: string;
}
export declare function hasCharacters(node: Node): node is Node & HasCharacters;
interface HasTypeStyle {
  readonly style: {
    readonly fontFamily: string;
    readonly fontPostScriptName?: string;
    readonly italic: boolean;
    readonly fontWeight: number;
    readonly fontSize: number;
    readonly textCase?:
      | "ORIGINAL"
      | "UPPER"
      | "LOWER"
      | "TITLE"
      | "SMALL_CAPS"
      | "SMALL_CAPS_FORCED";
    readonly textDecoration?: "NONE" | "STRIKETHROUGH" | "UNDERLINE";
    readonly textAlignHorizontal: "LEFT" | "RIGHT" | "CENTER" | "JUSTIFIED";
    readonly letterSpacing: number;
    readonly lineHeightPx: number;
    readonly lineHeightPercentFontSize?: number;
    readonly lineHeightUnit: "PIXELS" | "FONT_SIZE_%" | "INTRINSIC_%";
  };
}
export declare function hasTypeStyle(node: Node): node is Node & HasTypeStyle;
export interface HasBoundingBox {
  readonly absoluteBoundingBox: Rectangle;
  /**
   * Old data may not have this property.
   */
  readonly absoluteRenderBounds?: Rectangle;
}
export declare function hasBoundingBox(
  node: Node,
): node is Node & HasBoundingBox;
export interface HasPadding {
  paddingTop: number;
  paddingRight: number;
  paddingBottom: number;
  paddingLeft: number;
}
export declare function hasPadding(node: Node): node is Node & HasPadding;
export interface HasLegacyPadding {
  horizontalPadding: number;
  verticalPadding: number;
}
export declare function hasLegacyPadding(
  node: Node,
): node is Node & HasLegacyPadding;
export interface HasChildren {
  readonly children: readonly Node[];
}
export declare function hasChildren(node: Node): node is Node & HasChildren;
interface HasRadius {
  readonly cornerRadius: number;
}
export declare function hasRadius(node: Node): node is Node & HasRadius;
interface HasRadii {
  readonly rectangleCornerRadii: readonly [number, number, number, number];
}
export declare function hasRadii(node: Node): node is Node & HasRadii;
export type KnownNodeType =
  | "DOCUMENT"
  | "CANVAS"
  | "FRAME"
  | "GROUP"
  | "SECTION"
  | "VECTOR"
  | "BOOLEAN_OPERATION"
  | "STAR"
  | "LINE"
  | "ELLIPSE"
  | "REGULAR_POLYGON"
  | "RECTANGLE"
  | "TABLE"
  | "TABLE_CELL"
  | "TEXT"
  | "SLICE"
  | "COMPONENT"
  | "COMPONENT_SET"
  | "INSTANCE"
  | "STICKY"
  | "SHAPE_WITH_TEXT"
  | "CONNECTOR"
  | "WASHI_TAPE";
/**
 * https://www.figma.com/developers/api#global-properties
 */
export interface Node<Type extends string = KnownNodeType | string> {
  readonly id: string;
  readonly name: string;
  /**
   * @default true
   */
  readonly visible?: boolean;
  readonly type: Type;
}
export declare function isNode(x: unknown): x is Node;
/**
 * Walk over the node and its descendants.
 * Iterator is superior to the common callback-style walk function:
 * - Ability to abort the traverse with standard language feature (return, break)
 * - No implicit call timing convention - TypeScript's poor inference engine completely
 *   ignores assignments even if the callback function will be called immediately.
 *   The inference system is built upon unrealistic illusion.
 *   https://github.com/microsoft/TypeScript/issues/9998
 * - (subjective) `for ~ of` over iterator is way more readable and easier to grasp than
 *   function invocation with unknown callback. When will the callback be invoked?
 *   What will happen when the callback function returned something?
 *
 * @param node - The root node to start traversing from. This function returns this parameter as a result at the very first.
 * @example
 * for (const node of walk(root)) {
 *   console.log(node.id)
 * }
 */
export declare function walk(node: Node): Generator<Node, void, undefined>;
export type Canvas = Node & HasChildren & HasBackgroundColor;
/**
 * Returns an iterator of CANVAS nodes.
 */
export declare function getCanvases(
  node: Node,
): Generator<Canvas, void, undefined>;
export interface GetFileNodesResponse {
  readonly name: string;
  readonly lastModified: string;
  readonly nodes: Record<
    string,
    {
      readonly document: Node;
    }
  >;
}
export interface GetFileResponse {
  readonly name: string;
  readonly lastModified: string;
  readonly document: Node & HasChildren;
}
export {};
