import { Signal } from "./signal.js";
export type ElementFn<T extends HTMLElement | SVGElement> = (el: T) => void;
type ToSignal<T> = T extends any ? Signal<T> : never;
type AttrValue = string | boolean;
/**
 * Set or remove an attribute.
 *
 * @param name - An attribute name.
 * @param value - `string` is set as-is. `boolean` follows HTML's boolean attribute semantics:
 *                `true` sets an empty string and `false` removes the attribute itself.
 */
export declare function attr<T extends HTMLElement | SVGElement>(
  name: string,
  value: AttrValue | ToSignal<AttrValue> | Signal<AttrValue>,
): ElementFn<T>;
/**
 * Assign a value to the property.
 */
export declare function prop<
  T extends HTMLElement | SVGElement,
  K extends keyof T,
>(key: K, value: T[K] | Signal<T[K]>): ElementFn<T>;
/**
 * Invoke the given callback after `requestAnimationFrame`.
 *
 * Provided as an escape-hatch for DOM quirks.
 *
 * @example
 * el("select", [
 *   raf(compute(() => (el) => {
 *     el.value = value.get();
 *   }))
 * ])
 */
export declare function raf<T extends HTMLElement | SVGElement>(
  f: ((el: T) => void) | Signal<(el: T) => void>,
): ElementFn<T>;
/**
 * Set element's inline style.
 *
 * This is not same as `HTMLElement.style.foo`: under the hood, `CSSStyleDeclaration.setProperty` is used.
 * Hence, property name must be hyphen-cased.
 * Property value can be one of `string`, `null`, or `undefined`.
 *
 * - `string`    ... Sets the value to the property.
 * - `null`      ... Removes the property from stylesheet.
 * - `undefined` ... Does nothing.
 *
 * When used with Signal, use of `undefined` would lead to confusing behavor.
 *
 * ```ts
 * const border = signal<string | undefined>("1px solid #000");
 * style({ border });
 * border.set(undefined)
 * ```
 *
 * In the above code, setting `undefined` does nothing: the actual border property's value
 * is still `1px solid #000`. In order to avoid these kind of surprising situation, use of
 * `string` is always recommended.
 *
 * ```ts
 * const border = signal("1px solid #000");
 * style({ border });
 * border.set("none")
 * ```
 */
export declare function style<T extends HTMLElement | SVGElement>(
  style: Record<
    string,
    string | null | undefined | Signal<string | null | undefined>
  >,
): ElementFn<T>;
/**
 * Sets a class or a list of classes.
 *
 * This function does not accept Signal.
 * Use `data-*` attribute or property for dynamic values.
 */
export declare function className<T extends HTMLElement | SVGElement>(
  ...value: readonly string[]
): ElementFn<T>;
/**
 * Attach an event listener.
 */
export declare function on<
  T extends HTMLElement,
  E extends keyof HTMLElementEventMap,
>(
  eventName: E,
  callback: (event: HTMLElementEventMap[E]) => void,
  options?: AddEventListenerOptions,
): ElementFn<HTMLElement>;
export declare function on<
  T extends SVGElement,
  E extends keyof SVGElementEventMap,
>(
  eventName: E,
  callback: (event: SVGElementEventMap[E]) => void,
  options?: AddEventListenerOptions,
): ElementFn<SVGElement>;
type ElementChild = HTMLElement | SVGElement | string | null | undefined;
/**
 * Create a HTML element.
 */
export declare function el<TagName extends keyof HTMLElementTagNameMap>(
  tagName: TagName,
  attrs?: readonly ElementFn<HTMLElementTagNameMap[TagName]>[],
  children?: readonly (
    | ElementChild
    | ToSignal<ElementChild>
    | Signal<ElementChild>
  )[],
): HTMLElementTagNameMap[TagName];
/**
 * Create a SVG element.
 *
 * You don't need to set `xmlns` attribute for elements created by this function.
 */
export declare function svg<TagName extends keyof SVGElementTagNameMap>(
  tagName: TagName,
  attrs?: readonly ElementFn<SVGElementTagNameMap[TagName]>[],
  children?: readonly (
    | ElementChild
    | ToSignal<ElementChild>
    | Signal<ElementChild>
  )[],
): SVGElementTagNameMap[TagName];
export {};
