var __classPrivateFieldGet =
  (this && this.__classPrivateFieldGet) ||
  function (receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (
      typeof state === "function"
        ? receiver !== state || !f
        : !state.has(receiver)
    )
      throw new TypeError(
        "Cannot read private member from an object whose class did not declare it",
      );
    return kind === "m"
      ? f
      : kind === "a"
      ? f.call(receiver)
      : f
      ? f.value
      : state.get(receiver);
  };
var __classPrivateFieldSet =
  (this && this.__classPrivateFieldSet) ||
  function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (
      typeof state === "function"
        ? receiver !== state || !f
        : !state.has(receiver)
    )
      throw new TypeError(
        "Cannot write private member to an object whose class did not declare it",
      );
    return (
      kind === "a"
        ? f.call(receiver, value)
        : f
        ? (f.value = value)
        : state.set(receiver, value),
      value
    );
  };
var _FrameCanvas_instances,
  _FrameCanvas_container,
  _FrameCanvas_canvas,
  _FrameCanvas_viewport,
  _FrameCanvas_hitboxToNodeMap,
  _FrameCanvas_x,
  _FrameCanvas_fitX,
  _FrameCanvas_y,
  _FrameCanvas_fitY,
  _FrameCanvas_scale,
  _FrameCanvas_fitScale,
  _FrameCanvas_preferences,
  _FrameCanvas_selected,
  _FrameCanvas_hovered,
  _FrameCanvas_isViewportHovered,
  _FrameCanvas_dragState,
  _FrameCanvas_isActive,
  _FrameCanvas_snackbar,
  _FrameCanvas_touchState,
  _FrameCanvas_touchingState,
  _FrameCanvas_activeGestureTouches,
  _FrameCanvas_transformQueue,
  _FrameCanvas_applyTransform,
  _FrameCanvas_drawGuide,
  _FrameCanvas_drawDistance,
  _FrameCanvas_onPointerDown,
  _FrameCanvas_onPointerUp,
  _FrameCanvas_onPointerMove,
  _FrameCanvas_onPointerOver,
  _FrameCanvas_onPointerLeave,
  _FrameCanvas_onWheel,
  _FrameCanvas_handleKeyDownPanOrScale,
  _FrameCanvas_focusIsInViewport,
  _FrameCanvas_focusIsInShadowRoot,
  _FrameCanvas_onKeyDown,
  _FrameCanvas_onKeyUp,
  _FrameCanvas_onTouchStart,
  _FrameCanvas_onTouchEnd,
  _FrameCanvas_onTouchCancel,
  _FrameCanvas_onTouchMove;
import { attr, className, el, on, style, svg } from "../dom.js";
import * as figma from "../figma.js";
import { roundTo, nextPowerOfTwo, previousPowerOfTwo } from "../math.js";
import { effect, Signal } from "../signal.js";
import { BoundingBoxMeasurement } from "./BoundingBoxMeasurement.js";
import { getDistanceGuides } from "./distanceGuide.js";
import { getRenderBoundingBox } from "./getRenderBoundingBox.js";
import * as TooltipLayer from "./TooltipLayer.js";
const MIN_SCALE = 2 ** -6;
const MAX_SCALE = 2 ** 8;
export class FrameCanvas {
  static get styles() {
    return (
      /* css */ `
      .fc-viewport {
        --tooltip-font-size: var(--guide-tooltip-font-size);

        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column-reverse;

        background-color: var(--canvas-bg);
        border-radius: var(--border-radius);
        touch-action: none;
      }
      .fc-viewport:focus-visible {
        outline: 2px solid SelectedItem;
        outline-offset: -3px;
      }

      .fc-canvas {
        position: absolute;
        top: 50%;
        left: 50%;
        flex: 1;

        overflow: visible;
      }

      .fc-rendered-image {
        position: absolute;
        top: 0;
        left: 0;

        overflow: hidden;
        pointer-events: none;
      }

      .fc-guide-canvas {
        position: absolute;

        overflow: visible;
        fill: none;
        stroke-width: calc(var(--guide-thickness) / var(--_scale, 1));
        pointer-events: none;
        z-index: calc(var(--z-index) + 3);
      }

      .fc-guide-selection-layer {
        stroke: var(--guide-selected-color);
      }

      .fc-tooltip-selection-layer {
        --tooltip-bg: var(--guide-selected-tooltip-bg);
        --tooltip-fg: var(--guide-selected-tooltip-fg);
      }

      .fc-guide-hover-layer {
        stroke: var(--guide-color);
      }

      .fc-tooltip-hover-layer {
        --tooltip-bg: var(--guide-tooltip-bg);
        --tooltip-fg: var(--guide-tooltip-fg);
      }

      .fc-hitbox-layer, .fc-hitbox {
        position: absolute;
      }

      .fc-hitbox-layer {
        top: 0;
        left: 0;
      }

      .fc-hitbox[data-select-mute] {
        pointer-events: none;
      }
    ` + TooltipLayer.styles
    );
  }
  get container() {
    return __classPrivateFieldGet(this, _FrameCanvas_container, "f");
  }
  constructor(preferences, selected, snackbar) {
    _FrameCanvas_instances.add(this);
    _FrameCanvas_container.set(this, void 0);
    _FrameCanvas_canvas.set(this, el("div", [className("fc-canvas")]));
    _FrameCanvas_viewport.set(this, void 0);
    _FrameCanvas_hitboxToNodeMap.set(this, new WeakMap());
    _FrameCanvas_x.set(this, 0);
    _FrameCanvas_fitX.set(this, 0);
    _FrameCanvas_y.set(this, 0);
    _FrameCanvas_fitY.set(this, 0);
    _FrameCanvas_scale.set(this, 1);
    _FrameCanvas_fitScale.set(this, 1);
    _FrameCanvas_preferences.set(this, void 0);
    _FrameCanvas_selected.set(this, void 0);
    _FrameCanvas_hovered.set(this, new Signal(null));
    _FrameCanvas_isViewportHovered.set(this, false);
    _FrameCanvas_dragState.set(this, new Signal(0 /* DragState.Disabled */));
    _FrameCanvas_isActive.set(this, false);
    _FrameCanvas_snackbar.set(this, void 0);
    _FrameCanvas_touchState.set(
      this,
      new Signal(0 /* TouchGestureState.Idle */),
    );
    _FrameCanvas_touchingState.set(this, new Signal(null));
    _FrameCanvas_activeGestureTouches.set(this, 0);
    /**
     * Single-element update queue for viewport CSS transform.
     */
    _FrameCanvas_transformQueue.set(this, null);
    _FrameCanvas_onPointerDown.set(this, (ev) => {
      if (
        __classPrivateFieldGet(this, _FrameCanvas_dragState, "f").once() !==
        1 /* DragState.Idle */
      ) {
        return;
      }
      ev.preventDefault();
      ev.stopPropagation();
      __classPrivateFieldGet(this, _FrameCanvas_dragState, "f").set(
        2 /* DragState.Dragging */,
      );
    });
    _FrameCanvas_onPointerUp.set(this, (ev) => {
      var _a;
      if (
        __classPrivateFieldGet(this, _FrameCanvas_activeGestureTouches, "f") > 0
      ) {
        __classPrivateFieldSet(
          this,
          _FrameCanvas_activeGestureTouches,
          ((_a = __classPrivateFieldGet(
            this,
            _FrameCanvas_activeGestureTouches,
            "f",
          )),
          _a--,
          _a),
          "f",
        );
        return;
      }
      ev.preventDefault();
      ev.stopPropagation();
      if (
        __classPrivateFieldGet(this, _FrameCanvas_dragState, "f").once() !==
        2 /* DragState.Dragging */
      ) {
        const node =
          (ev.target &&
            ev.target instanceof Element &&
            __classPrivateFieldGet(this, _FrameCanvas_hitboxToNodeMap, "f").get(
              ev.target,
            )) ||
          null;
        this.select(node);
        return;
      }
      __classPrivateFieldGet(this, _FrameCanvas_dragState, "f").set(
        1 /* DragState.Idle */,
      );
    });
    _FrameCanvas_onPointerMove.set(this, (ev) => {
      // Performs pan when middle button is pressed or component is in Dragging state.
      //
      // 4 ... Auxiliary button (usually the mouse wheel button or middle button)
      // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons
      if (
        !(
          (
            ev.buttons & 4 ||
            __classPrivateFieldGet(this, _FrameCanvas_dragState, "f").once() ===
              2
          ) /* DragState.Dragging */
        )
      ) {
        return;
      }
      ev.preventDefault();
      __classPrivateFieldSet(
        this,
        _FrameCanvas_x,
        __classPrivateFieldGet(this, _FrameCanvas_x, "f") +
          ev.movementX / __classPrivateFieldGet(this, _FrameCanvas_scale, "f"),
        "f",
      );
      __classPrivateFieldSet(
        this,
        _FrameCanvas_y,
        __classPrivateFieldGet(this, _FrameCanvas_y, "f") +
          ev.movementY / __classPrivateFieldGet(this, _FrameCanvas_scale, "f"),
        "f",
      );
      __classPrivateFieldGet(
        this,
        _FrameCanvas_instances,
        "m",
        _FrameCanvas_applyTransform,
      ).call(this);
    });
    _FrameCanvas_onPointerOver.set(this, (ev) => {
      if (!ev.target || !(ev.target instanceof Element)) {
        return;
      }
      __classPrivateFieldSet(this, _FrameCanvas_isViewportHovered, true, "f");
      const node = __classPrivateFieldGet(
        this,
        _FrameCanvas_hitboxToNodeMap,
        "f",
      ).get(ev.target);
      if (!node) {
        return;
      }
      ev.stopPropagation();
      __classPrivateFieldGet(this, _FrameCanvas_hovered, "f").set(node);
    });
    _FrameCanvas_onPointerLeave.set(this, (_ev) => {
      __classPrivateFieldSet(this, _FrameCanvas_isViewportHovered, false, "f");
      __classPrivateFieldGet(this, _FrameCanvas_hovered, "f").set(null);
    });
    _FrameCanvas_onWheel.set(this, (ev) => {
      if (!__classPrivateFieldGet(this, _FrameCanvas_isActive, "f")) {
        return;
      }
      ev.preventDefault();
      if (ev.ctrlKey) {
        // Performs zoom when ctrl key is pressed.
        let { deltaY } = ev;
        switch (ev.deltaMode) {
          // DOM_DELTA_LINE
          case 1: {
            // Hard-coded because it's nearly impossible to obtain scroll amount in pixel
            // when UA uses DOM_DELTA_LINE (technically possible but it's too hacky and
            // comes with huge performance penalty).
            deltaY *= 15;
            break;
          }
          // DOM_DELTA_PAGE
          case 2: {
            // Honestly, I don't know how to deal with this one...
            // 100 because it's larger than 15 :)
            deltaY *= 100;
            break;
          }
        }
        const prevScale = __classPrivateFieldGet(this, _FrameCanvas_scale, "f");
        // Clamp scale between MIN_SCALE and MAX_SCALE
        __classPrivateFieldSet(
          this,
          _FrameCanvas_scale,
          Math.max(
            MIN_SCALE,
            Math.min(
              MAX_SCALE,
              __classPrivateFieldGet(this, _FrameCanvas_scale, "f") *
                (1 -
                  deltaY /
                    ((1000 -
                      __classPrivateFieldGet(
                        this,
                        _FrameCanvas_preferences,
                        "f",
                      ).viewportZoomSpeed) *
                      0.5)),
            ),
          ),
          "f",
        );
        // Calling layout-read method on every `wheel` event is not desirable.
        // While `getBoundingClientRect` in here runs immediately according to Chrome performance
        // profiler (Firefox profiler is hot garbage), not accessing layout-related
        // properties and methods is easy to estimate and optimise.
        // However, this call is necessary due to the stupid standard provides no way to
        // explicitly limit `wheel` event target and/or prevent `wheel` action happening from
        // a particular element, like `touch-action`. Because of this shitty situation,
        // the `offsetX` and `offsetY` change their value semantics ("where is the origin?"")
        // based on now-hovered element. So most of the time the origin point would be
        // `.fc-rendered-image`'s left-top point, not `.fc-viewport`'s one.
        // Subtracting boundingClientRect's x/y from `MouseEvent.clientX/Y` is the
        // simplest and most perfomant way to calculate "offsetX/Y for currentTarget" I can
        // think of. If there is a better way to compute a relative pointer position
        // inside `.fc-viewport` without perfomance compromise, you should rewrite these
        // logic and remove this comment to bring calm and peace to the project.
        const viewport = __classPrivateFieldGet(
          this,
          _FrameCanvas_viewport,
          "f",
        ).getBoundingClientRect();
        const [offsetX, offsetY] =
          !ev.target || ev.target === ev.currentTarget
            ? [ev.offsetX, ev.offsetY]
            : [ev.clientX - viewport.x, ev.clientY - viewport.y];
        const pointerOffsetX = offsetX - viewport.width * 0.5;
        const pointerOffsetY = offsetY - viewport.height * 0.5;
        // Performs pan to archive "zoom at the pointer" behavior.
        __classPrivateFieldSet(
          this,
          _FrameCanvas_x,
          __classPrivateFieldGet(this, _FrameCanvas_x, "f") +
            (pointerOffsetX /
              __classPrivateFieldGet(this, _FrameCanvas_scale, "f") -
              pointerOffsetX / prevScale),
          "f",
        );
        __classPrivateFieldSet(
          this,
          _FrameCanvas_y,
          __classPrivateFieldGet(this, _FrameCanvas_y, "f") +
            (pointerOffsetY /
              __classPrivateFieldGet(this, _FrameCanvas_scale, "f") -
              pointerOffsetY / prevScale),
          "f",
        );
      } else {
        // Performs pan otherwise (to be close to native behavior)
        // Adjusting panSpeed in order to make panSpeed=500 to match to the Figma's one.
        const speed =
          __classPrivateFieldGet(this, _FrameCanvas_preferences, "f")
            .viewportPanSpeed * 0.002;
        __classPrivateFieldSet(
          this,
          _FrameCanvas_x,
          __classPrivateFieldGet(this, _FrameCanvas_x, "f") -
            (ev.deltaX * speed) /
              __classPrivateFieldGet(this, _FrameCanvas_scale, "f"),
          "f",
        );
        __classPrivateFieldSet(
          this,
          _FrameCanvas_y,
          __classPrivateFieldGet(this, _FrameCanvas_y, "f") -
            (ev.deltaY * speed) /
              __classPrivateFieldGet(this, _FrameCanvas_scale, "f"),
          "f",
        );
      }
      __classPrivateFieldGet(
        this,
        _FrameCanvas_instances,
        "m",
        _FrameCanvas_applyTransform,
      ).call(this);
    });
    // Handles pan and scale with keyboard shortcuts
    // arrow keys for pan and -/=(+) for zoom
    // ! for zoom to fit, 0 for zoom to 100%
    _FrameCanvas_handleKeyDownPanOrScale.set(this, (ev) => {
      if (
        ![
          "ArrowUp",
          "ArrowDown",
          "ArrowLeft",
          "ArrowRight",
          "=",
          "-",
          "0",
          "!",
        ].includes(ev.key) ||
        !__classPrivateFieldGet(
          this,
          _FrameCanvas_instances,
          "m",
          _FrameCanvas_focusIsInShadowRoot,
        ).call(this) ||
        ev.ctrlKey ||
        ev.metaKey
      ) {
        return;
      }
      ev.preventDefault();
      ev.stopPropagation();
      if (ev.key === "!") {
        __classPrivateFieldSet(
          this,
          _FrameCanvas_scale,
          __classPrivateFieldGet(this, _FrameCanvas_fitScale, "f"),
          "f",
        );
        __classPrivateFieldSet(
          this,
          _FrameCanvas_x,
          __classPrivateFieldGet(this, _FrameCanvas_fitX, "f"),
          "f",
        );
        __classPrivateFieldSet(
          this,
          _FrameCanvas_y,
          __classPrivateFieldGet(this, _FrameCanvas_fitY, "f"),
          "f",
        );
        __classPrivateFieldGet(this, _FrameCanvas_snackbar, "f").set([
          "Zoomed to fit",
        ]);
      } else if (ev.key === "0") {
        __classPrivateFieldSet(this, _FrameCanvas_scale, 1, "f");
        __classPrivateFieldGet(this, _FrameCanvas_snackbar, "f").set([
          "Zoomed to 100%",
        ]);
      } else if (ev.key === "=" || ev.key === "-") {
        // Matches Figma's keyboard zoom behavior
        // Figma changes current scale to next/previous (in/out) power of two (including negative powers)
        __classPrivateFieldSet(
          this,
          _FrameCanvas_scale,
          ev.key === "="
            ? nextPowerOfTwo(
                __classPrivateFieldGet(this, _FrameCanvas_scale, "f"),
                { min: MIN_SCALE, max: MAX_SCALE },
              )
            : previousPowerOfTwo(
                __classPrivateFieldGet(this, _FrameCanvas_scale, "f"),
                { min: MIN_SCALE, max: MAX_SCALE },
              ),
          "f",
        );
      } else {
        // Figma moves ~65px per keydown, 13 percent of the default viewport pan speed of 500 is 65px;
        const distance =
          __classPrivateFieldGet(this, _FrameCanvas_preferences, "f")
            .viewportPanSpeed * 0.13;
        __classPrivateFieldSet(
          this,
          _FrameCanvas_x,
          __classPrivateFieldGet(this, _FrameCanvas_x, "f") +
            (ev.key === "ArrowLeft"
              ? distance
              : ev.key === "ArrowRight"
              ? -distance
              : 0),
          "f",
        );
        __classPrivateFieldSet(
          this,
          _FrameCanvas_y,
          __classPrivateFieldGet(this, _FrameCanvas_y, "f") +
            (ev.key === "ArrowDown"
              ? -distance
              : ev.key === "ArrowUp"
              ? distance
              : 0),
          "f",
        );
      }
      __classPrivateFieldGet(
        this,
        _FrameCanvas_instances,
        "m",
        _FrameCanvas_applyTransform,
      ).call(this);
    });
    _FrameCanvas_onKeyDown.set(this, (ev) => {
      __classPrivateFieldGet(
        this,
        _FrameCanvas_handleKeyDownPanOrScale,
        "f",
      ).call(this, ev);
      if (ev.key !== FrameCanvas.DRAG_MODE_KEY) {
        return;
      }
      // If drag state is already enabled or idle, prevent default and exit
      if (
        __classPrivateFieldGet(this, _FrameCanvas_dragState, "f").once() !==
        0 /* DragState.Disabled */
      ) {
        ev.preventDefault();
        ev.stopPropagation();
        return;
      }
      // If the viewport is not hovered or focus is elsewhere except the body, exit
      if (
        !__classPrivateFieldGet(this, _FrameCanvas_isViewportHovered, "f") ||
        (!__classPrivateFieldGet(
          this,
          _FrameCanvas_instances,
          "m",
          _FrameCanvas_focusIsInViewport,
        ).call(this) &&
          document.activeElement !== document.body)
      ) {
        return;
      }
      // Otherwise prevent default and set the drag state to idle
      ev.preventDefault();
      ev.stopPropagation();
      __classPrivateFieldGet(this, _FrameCanvas_dragState, "f").set(
        1 /* DragState.Idle */,
      );
    });
    _FrameCanvas_onKeyUp.set(this, (ev) => {
      if (
        ev.key !== FrameCanvas.DRAG_MODE_KEY ||
        __classPrivateFieldGet(this, _FrameCanvas_dragState, "f").once() ===
          0 /* DragState.Disabled */
      ) {
        return;
      }
      ev.preventDefault();
      ev.stopPropagation();
      __classPrivateFieldGet(this, _FrameCanvas_dragState, "f").set(
        0 /* DragState.Disabled */,
      );
    });
    _FrameCanvas_onTouchStart.set(this, (ev) => {
      const firstTouch = ev.touches.item(0);
      if (!firstTouch) {
        return;
      }
      if (
        __classPrivateFieldGet(this, _FrameCanvas_touchState, "f").once() ===
        0 /* TouchGestureState.Idle */
      ) {
        __classPrivateFieldGet(this, _FrameCanvas_touchState, "f").set(
          1 /* TouchGestureState.Touching */,
        );
      }
      if (ev.touches.length >= 2) {
        __classPrivateFieldSet(
          this,
          _FrameCanvas_activeGestureTouches,
          __classPrivateFieldGet(this, _FrameCanvas_activeGestureTouches, "f") +
            ev.touches.length,
          "f",
        );
        const initialDist = getTouchAvgDist(ev.touches);
        if (initialDist === null) {
          return;
        }
        __classPrivateFieldGet(this, _FrameCanvas_touchingState, "f").set({
          mode: 1 /* TouchingStateModes.Scaling */,
          initialScale: __classPrivateFieldGet(this, _FrameCanvas_scale, "f"),
          initialDist,
        });
        return;
      }
      __classPrivateFieldGet(this, _FrameCanvas_touchingState, "f").set({
        mode: 0 /* TouchingStateModes.Panning */,
        initialTouch: firstTouch,
        initialX: __classPrivateFieldGet(this, _FrameCanvas_x, "f"),
        initialY: __classPrivateFieldGet(this, _FrameCanvas_y, "f"),
      });
    });
    _FrameCanvas_onTouchEnd.set(this, (ev) => {
      if (
        __classPrivateFieldGet(this, _FrameCanvas_touchState, "f").once() ===
        0 /* TouchGestureState.Idle */
      ) {
        return;
      }
      switch (ev.touches.length) {
        case 0: {
          __classPrivateFieldGet(this, _FrameCanvas_touchState, "f").set(
            0 /* TouchGestureState.Idle */,
          );
          __classPrivateFieldGet(this, _FrameCanvas_touchingState, "f").set(
            null,
          );
          return;
        }
        case 1: {
          __classPrivateFieldGet(this, _FrameCanvas_touchingState, "f").set({
            mode: 0 /* TouchingStateModes.Panning */,
            initialTouch: ev.touches.item(0),
            initialX: __classPrivateFieldGet(this, _FrameCanvas_x, "f"),
            initialY: __classPrivateFieldGet(this, _FrameCanvas_y, "f"),
          });
          return;
        }
        case 2: {
          const initialDist = getTouchAvgDist(ev.touches);
          if (initialDist === null) {
            return;
          }
          __classPrivateFieldGet(this, _FrameCanvas_touchingState, "f").set({
            mode: 1 /* TouchingStateModes.Scaling */,
            initialDist,
            initialScale: __classPrivateFieldGet(this, _FrameCanvas_scale, "f"),
          });
        }
      }
    });
    _FrameCanvas_onTouchCancel.set(this, () => {
      __classPrivateFieldGet(this, _FrameCanvas_touchState, "f").set(
        0 /* TouchGestureState.Idle */,
      );
    });
    _FrameCanvas_onTouchMove.set(this, (ev) => {
      var _a;
      if (
        __classPrivateFieldGet(this, _FrameCanvas_activeGestureTouches, "f") ===
        0
      ) {
        __classPrivateFieldSet(
          this,
          _FrameCanvas_activeGestureTouches,
          ((_a = __classPrivateFieldGet(
            this,
            _FrameCanvas_activeGestureTouches,
            "f",
          )),
          _a++,
          _a),
          "f",
        );
      }
      if (
        __classPrivateFieldGet(this, _FrameCanvas_touchState, "f").once() ===
        0 /* TouchGestureState.Idle */
      ) {
        return;
      }
      const state = __classPrivateFieldGet(
        this,
        _FrameCanvas_touchingState,
        "f",
      ).once();
      if (!state) {
        return;
      }
      if (state.mode === 0 /* TouchingStateModes.Panning */) {
        __classPrivateFieldSet(
          this,
          _FrameCanvas_x,
          state.initialX + (ev.touches[0].clientX - state.initialTouch.clientX),
          "f",
        );
        __classPrivateFieldSet(
          this,
          _FrameCanvas_y,
          state.initialY + (ev.touches[0].clientY - state.initialTouch.clientY),
          "f",
        );
        __classPrivateFieldGet(
          this,
          _FrameCanvas_instances,
          "m",
          _FrameCanvas_applyTransform,
        ).call(this);
        return;
      }
      const dist = getTouchAvgDist(ev.touches);
      if (dist === null) {
        return;
      }
      __classPrivateFieldSet(
        this,
        _FrameCanvas_scale,
        state.initialScale * (dist / state.initialDist),
        "f",
      );
      __classPrivateFieldGet(
        this,
        _FrameCanvas_instances,
        "m",
        _FrameCanvas_applyTransform,
      ).call(this);
    });
    effect(() => {
      __classPrivateFieldSet(
        this,
        _FrameCanvas_preferences,
        preferences.get(),
        "f",
      );
    });
    __classPrivateFieldSet(this, _FrameCanvas_container, el("div"), "f");
    __classPrivateFieldSet(this, _FrameCanvas_selected, selected, "f");
    __classPrivateFieldSet(this, _FrameCanvas_snackbar, snackbar, "f");
    __classPrivateFieldSet(
      this,
      _FrameCanvas_viewport,
      el(
        "div",
        [
          className("fc-viewport"),
          attr("tabindex", "0"),
          // Some UA defaults to passive (breaking but they did it anyway).
          // This component prevents every native wheel behavior on it.
          on("wheel", __classPrivateFieldGet(this, _FrameCanvas_onWheel, "f"), {
            passive: false,
          }),
          on(
            "pointerdown",
            __classPrivateFieldGet(this, _FrameCanvas_onPointerDown, "f"),
          ),
          on(
            "pointerup",
            __classPrivateFieldGet(this, _FrameCanvas_onPointerUp, "f"),
          ),
          on(
            "pointermove",
            __classPrivateFieldGet(this, _FrameCanvas_onPointerMove, "f"),
          ),
          on(
            "pointerover",
            __classPrivateFieldGet(this, _FrameCanvas_onPointerOver, "f"),
          ),
          on(
            "pointerout",
            __classPrivateFieldGet(this, _FrameCanvas_onPointerLeave, "f"),
          ),
          on(
            "touchstart",
            __classPrivateFieldGet(this, _FrameCanvas_onTouchStart, "f"),
          ),
          on(
            "touchend",
            __classPrivateFieldGet(this, _FrameCanvas_onTouchEnd, "f"),
          ),
          on(
            "touchcancel",
            __classPrivateFieldGet(this, _FrameCanvas_onTouchCancel, "f"),
          ),
          on(
            "touchmove",
            __classPrivateFieldGet(this, _FrameCanvas_onTouchMove, "f"),
          ),
        ],
        [__classPrivateFieldGet(this, _FrameCanvas_canvas, "f")],
      ),
      "f",
    );
    __classPrivateFieldGet(this, _FrameCanvas_container, "f").appendChild(
      __classPrivateFieldGet(this, _FrameCanvas_viewport, "f"),
    );
  }
  /**
   * Render a Figma frame to a DOM element.
   *
   * @param nodes
   * @param renderedImages
   */
  render(nodes, renderedImages, backgroundColor) {
    this.clear();
    const bbox = new BoundingBoxMeasurement();
    const hitboxLayer = el("div", [className("fc-hitbox-layer")], []);
    for (const child of nodes) {
      for (const node of figma.walk(child)) {
        if (!figma.hasBoundingBox(node)) {
          continue;
        }
        bbox.addNode(node);
        const renderedImage = renderedImages.get(node.id);
        if (renderedImage) {
          const box = getRenderBoundingBox(node);
          const img = el("img", [
            attr("src", renderedImage),
            attr("alt", `Figma frame: ${node.name}`),
            className("fc-rendered-image"),
            style({
              left: box.x + "px",
              top: box.y + "px",
              width: box.width + "px",
              height: box.height + "px",
            }),
          ]);
          __classPrivateFieldGet(this, _FrameCanvas_canvas, "f").appendChild(
            img,
          );
        }
        const { x, y, width, height } = node.absoluteBoundingBox;
        const radius = figma.hasRadius(node)
          ? {
              topLeft: node.cornerRadius,
              topRight: node.cornerRadius,
              bottomRight: node.cornerRadius,
              bottomLeft: node.cornerRadius,
            }
          : figma.hasRadii(node)
          ? {
              topLeft: node.rectangleCornerRadii[0],
              topRight: node.rectangleCornerRadii[1],
              bottomRight: node.rectangleCornerRadii[2],
              bottomLeft: node.rectangleCornerRadii[3],
            }
          : {
              topLeft: 0,
              topRight: 0,
              bottomRight: 0,
              bottomLeft: 0,
            };
        const hitbox = el(
          "div",
          [
            className("fc-hitbox"),
            attr("data-node-id", node.id),
            style({
              top: y + "px",
              left: x + "px",
              width: width + "px",
              height: height + "px",
              "border-top-left-radius": radius.topLeft + "px",
              "border-top-right-radius": radius.topRight + "px",
              "border-bottom-right-radius": radius.bottomRight + "px",
              "border-bottom-left-radius": radius.bottomLeft + "px",
            }),
          ],
          [],
        );
        __classPrivateFieldGet(this, _FrameCanvas_hitboxToNodeMap, "f").set(
          hitbox,
          node,
        );
        hitboxLayer.appendChild(hitbox);
      }
    }
    const boundingRect = bbox.measure();
    requestAnimationFrame(() => {
      const viewportSize = __classPrivateFieldGet(
        this,
        _FrameCanvas_viewport,
        "f",
      ).getBoundingClientRect();
      __classPrivateFieldSet(
        this,
        _FrameCanvas_fitScale,
        Math.min(
          viewportSize.width / boundingRect.width,
          viewportSize.height / boundingRect.height,
        ) * 0.75,
        "f",
      );
      __classPrivateFieldSet(
        this,
        _FrameCanvas_scale,
        __classPrivateFieldGet(this, _FrameCanvas_fitScale, "f"),
        "f",
      );
      __classPrivateFieldGet(
        this,
        _FrameCanvas_instances,
        "m",
        _FrameCanvas_applyTransform,
      ).call(this);
    });
    if (backgroundColor) {
      const { r, g, b, a } = backgroundColor;
      __classPrivateFieldGet(
        this,
        _FrameCanvas_viewport,
        "f",
      ).style.backgroundColor = `rgb(${(r * 0xff) | 0} ${(g * 0xff) | 0} ${
        (b * 0xff) | 0
      } / ${a})`;
    }
    __classPrivateFieldGet(this, _FrameCanvas_canvas, "f").style.width =
      boundingRect.width + "px";
    __classPrivateFieldGet(this, _FrameCanvas_canvas, "f").style.height =
      boundingRect.height + "px";
    hitboxLayer.style.width = boundingRect.width + "px";
    hitboxLayer.style.height = boundingRect.height + "px";
    __classPrivateFieldGet(this, _FrameCanvas_canvas, "f").appendChild(
      hitboxLayer,
    );
    __classPrivateFieldSet(this, _FrameCanvas_fitX, -boundingRect.x, "f");
    __classPrivateFieldSet(this, _FrameCanvas_fitY, -boundingRect.y, "f");
    __classPrivateFieldSet(
      this,
      _FrameCanvas_x,
      __classPrivateFieldGet(this, _FrameCanvas_fitX, "f"),
      "f",
    );
    __classPrivateFieldSet(
      this,
      _FrameCanvas_y,
      __classPrivateFieldGet(this, _FrameCanvas_fitY, "f"),
      "f",
    );
    const hoverGuideLayer = svg("g", [className("fc-guide-hover-layer")]);
    const hoverTooltipLayer = new TooltipLayer.TooltipLayer(
      svg("g", [className("fc-tooltip-hover-layer")]),
    );
    const selectionGuideLayer = svg("g", [
      className("fc-guide-selection-layer"),
    ]);
    const selectionTooltipLayer = new TooltipLayer.TooltipLayer(
      svg("g", [className("fc-tooltip-selection-layer")]),
    );
    __classPrivateFieldGet(this, _FrameCanvas_canvas, "f").appendChild(
      svg(
        "svg",
        [
          className("fc-guide-canvas"),
          attr(
            "viewBox",
            [
              boundingRect.x,
              boundingRect.y,
              boundingRect.width,
              boundingRect.height,
            ].join(" "),
          ),
          style({
            left: boundingRect.x + "px",
            top: boundingRect.y + "px",
            width: boundingRect.width + "px",
            height: boundingRect.height + "px",
          }),
        ],
        [
          hoverGuideLayer,
          selectionGuideLayer,
          selectionTooltipLayer.container,
          hoverTooltipLayer.container,
        ],
      ),
    );
    // Draw guides on select
    effect(() => {
      const selected = __classPrivateFieldGet(
        this,
        _FrameCanvas_selected,
        "f",
      ).get();
      selectionGuideLayer.replaceChildren();
      __classPrivateFieldGet(
        this,
        _FrameCanvas_instances,
        "m",
        _FrameCanvas_drawGuide,
      ).call(this, selected, selectionGuideLayer);
      selectionTooltipLayer.clear();
      if (selected && figma.hasBoundingBox(selected)) {
        const {
          absoluteBoundingBox: { x, y, width, height },
        } = selected;
        selectionTooltipLayer.show(
          `${roundTo(
            width,
            __classPrivateFieldGet(this, _FrameCanvas_preferences, "f")
              .decimalPlaces,
          )} Ã— ${roundTo(
            height,
            __classPrivateFieldGet(this, _FrameCanvas_preferences, "f")
              .decimalPlaces,
          )}`,
          x + width * 0.5,
          y + height,
          TooltipLayer.BOTTOM,
        );
      }
      // Disable selected hitbox so a user can click backward elements with
      // exact same position/size.
      if (selected) {
        const hitbox = hitboxLayer.querySelector(
          `[data-node-id="${selected.id}"]`,
        );
        if (hitbox) {
          hitbox.setAttribute("data-select-mute", "");
          return () => {
            hitbox.removeAttribute("data-select-mute");
          };
        }
      }
    });
    // Draw guides on hover
    effect(() => {
      const selected = __classPrivateFieldGet(
        this,
        _FrameCanvas_selected,
        "f",
      ).get();
      const hovered = __classPrivateFieldGet(
        this,
        _FrameCanvas_hovered,
        "f",
      ).get();
      if (!hovered) {
        return;
      }
      hoverGuideLayer.replaceChildren();
      __classPrivateFieldGet(
        this,
        _FrameCanvas_instances,
        "m",
        _FrameCanvas_drawGuide,
      ).call(this, hovered, hoverGuideLayer);
      if (selected) {
        hoverTooltipLayer.clear();
        __classPrivateFieldGet(
          this,
          _FrameCanvas_instances,
          "m",
          _FrameCanvas_drawDistance,
        ).call(this, selected, hovered, hoverGuideLayer, hoverTooltipLayer);
      }
      return () => {
        hoverGuideLayer.replaceChildren();
        hoverTooltipLayer.clear();
      };
    });
    // Change cursor based on drag state
    effect(() => {
      switch (__classPrivateFieldGet(this, _FrameCanvas_dragState, "f").get()) {
        case 2 /* DragState.Dragging */: {
          document.body.style.cursor = "grabbing";
          return () => {
            document.body.style.cursor = "auto";
          };
        }
        case 1 /* DragState.Idle */: {
          document.body.style.cursor = "grab";
          return () => {
            document.body.style.cursor = "auto";
          };
        }
      }
    });
    __classPrivateFieldSet(this, _FrameCanvas_isActive, true, "f");
    __classPrivateFieldGet(
      this,
      _FrameCanvas_instances,
      "m",
      _FrameCanvas_applyTransform,
    ).call(this);
  }
  /**
   * Clear the viewport.
   */
  clear() {
    __classPrivateFieldGet(this, _FrameCanvas_canvas, "f").replaceChildren();
    __classPrivateFieldSet(this, _FrameCanvas_isActive, false, "f");
  }
  /**
   * Reset the canvas state.
   * This method does not clear the canvas.
   */
  reset() {
    __classPrivateFieldSet(this, _FrameCanvas_x, 0, "f");
    __classPrivateFieldSet(this, _FrameCanvas_y, 0, "f");
    __classPrivateFieldSet(this, _FrameCanvas_scale, 1, "f");
    __classPrivateFieldGet(
      this,
      _FrameCanvas_instances,
      "m",
      _FrameCanvas_applyTransform,
    ).call(this);
  }
  select(node) {
    __classPrivateFieldGet(this, _FrameCanvas_selected, "f").set(node);
  }
  connectedCallback() {
    document.addEventListener(
      "keydown",
      __classPrivateFieldGet(this, _FrameCanvas_onKeyDown, "f"),
    );
    document.addEventListener(
      "keyup",
      __classPrivateFieldGet(this, _FrameCanvas_onKeyUp, "f"),
    );
  }
  disconnectedCallback() {
    document.removeEventListener(
      "keydown",
      __classPrivateFieldGet(this, _FrameCanvas_onKeyDown, "f"),
    );
    document.removeEventListener(
      "keyup",
      __classPrivateFieldGet(this, _FrameCanvas_onKeyUp, "f"),
    );
  }
}
(_FrameCanvas_container = new WeakMap()),
  (_FrameCanvas_canvas = new WeakMap()),
  (_FrameCanvas_viewport = new WeakMap()),
  (_FrameCanvas_hitboxToNodeMap = new WeakMap()),
  (_FrameCanvas_x = new WeakMap()),
  (_FrameCanvas_fitX = new WeakMap()),
  (_FrameCanvas_y = new WeakMap()),
  (_FrameCanvas_fitY = new WeakMap()),
  (_FrameCanvas_scale = new WeakMap()),
  (_FrameCanvas_fitScale = new WeakMap()),
  (_FrameCanvas_preferences = new WeakMap()),
  (_FrameCanvas_selected = new WeakMap()),
  (_FrameCanvas_hovered = new WeakMap()),
  (_FrameCanvas_isViewportHovered = new WeakMap()),
  (_FrameCanvas_dragState = new WeakMap()),
  (_FrameCanvas_isActive = new WeakMap()),
  (_FrameCanvas_snackbar = new WeakMap()),
  (_FrameCanvas_touchState = new WeakMap()),
  (_FrameCanvas_touchingState = new WeakMap()),
  (_FrameCanvas_activeGestureTouches = new WeakMap()),
  (_FrameCanvas_transformQueue = new WeakMap()),
  (_FrameCanvas_onPointerDown = new WeakMap()),
  (_FrameCanvas_onPointerUp = new WeakMap()),
  (_FrameCanvas_onPointerMove = new WeakMap()),
  (_FrameCanvas_onPointerOver = new WeakMap()),
  (_FrameCanvas_onPointerLeave = new WeakMap()),
  (_FrameCanvas_onWheel = new WeakMap()),
  (_FrameCanvas_handleKeyDownPanOrScale = new WeakMap()),
  (_FrameCanvas_onKeyDown = new WeakMap()),
  (_FrameCanvas_onKeyUp = new WeakMap()),
  (_FrameCanvas_onTouchStart = new WeakMap()),
  (_FrameCanvas_onTouchEnd = new WeakMap()),
  (_FrameCanvas_onTouchCancel = new WeakMap()),
  (_FrameCanvas_onTouchMove = new WeakMap()),
  (_FrameCanvas_instances = new WeakSet()),
  (_FrameCanvas_applyTransform = function _FrameCanvas_applyTransform() {
    // Schedule an update for next frame.
    // Probably it's safe to schedule without `if` guard, but there is no reason
    // to push unnecessary no-op callbacks to the RAF queue.
    if (!__classPrivateFieldGet(this, _FrameCanvas_transformQueue, "f")) {
      requestAnimationFrame(() => {
        if (!__classPrivateFieldGet(this, _FrameCanvas_transformQueue, "f")) {
          return;
        }
        __classPrivateFieldGet(this, _FrameCanvas_canvas, "f").style.transform =
          __classPrivateFieldGet(this, _FrameCanvas_transformQueue, "f");
        __classPrivateFieldGet(
          this,
          _FrameCanvas_canvas,
          "f",
        ).style.setProperty(
          "--_scale",
          __classPrivateFieldGet(this, _FrameCanvas_scale, "f").toPrecision(5),
        );
        __classPrivateFieldSet(this, _FrameCanvas_transformQueue, null, "f");
      });
    }
    // prettier-ignore
    // Prettier breaks down this into fucking ugly multiline code if we omit the above line,
    // but I don't wanna add an unnecessary runtime computation (`[...].join("\n")`)
    // just because source code is ugly. It seems newer Prettier versions changed this
    // behaviour so I should try it. Still no option to disable this feature, though.
    __classPrivateFieldSet(this, _FrameCanvas_transformQueue, `translate(-50%, -50%) scale(${__classPrivateFieldGet(this, _FrameCanvas_scale, "f")}) translate(${__classPrivateFieldGet(this, _FrameCanvas_x, "f")}px, ${__classPrivateFieldGet(this, _FrameCanvas_y, "f")}px)`, "f");
  }),
  (_FrameCanvas_drawGuide = function _FrameCanvas_drawGuide(node, layer) {
    if (!node || !figma.hasBoundingBox(node)) {
      return;
    }
    const { x, y, width, height } = node.absoluteBoundingBox;
    const radius = figma.hasRadius(node)
      ? {
          topLeft: node.cornerRadius,
          topRight: node.cornerRadius,
          bottomRight: node.cornerRadius,
          bottomLeft: node.cornerRadius,
        }
      : figma.hasRadii(node)
      ? {
          topLeft: node.rectangleCornerRadii[0],
          topRight: node.rectangleCornerRadii[1],
          bottomRight: node.rectangleCornerRadii[2],
          bottomLeft: node.rectangleCornerRadii[3],
        }
      : {
          topLeft: 0,
          topRight: 0,
          bottomRight: 0,
          bottomLeft: 0,
        };
    // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/d
    // [M] ... Move to
    // [L] ... Line to
    // [A] ... Arc to
    // [Z] ... Close path
    const moveTo = (tx, ty) => `M${x + tx},${y + ty}`;
    const lineTo = (tx, ty) => `L${x + tx},${y + ty}`;
    const arcTo = (r, tx, ty) => `A${r},${r} 0 0 1 ${x + tx},${y + ty}`;
    const boxPath = [
      moveTo(radius.topLeft, 0),
      lineTo(width - radius.topRight, 0),
      arcTo(radius.topRight, width, radius.topRight),
      lineTo(width, height - radius.bottomRight),
      arcTo(radius.bottomRight, width - radius.bottomRight, height),
      lineTo(radius.bottomLeft, height),
      arcTo(radius.bottomLeft, 0, height - radius.bottomLeft),
      lineTo(0, radius.topLeft),
      arcTo(radius.topLeft, radius.topLeft, 0),
      "Z",
    ].join(" ");
    const guide = svg("path", [attr("d", boxPath)], []);
    layer.appendChild(guide);
  }),
  (_FrameCanvas_drawDistance = function _FrameCanvas_drawDistance(
    from,
    to,
    guideLayer,
    tooltipLayer,
  ) {
    if (!figma.hasBoundingBox(from) || !figma.hasBoundingBox(to)) {
      return;
    }
    const guides = getDistanceGuides(
      from.absoluteBoundingBox,
      to.absoluteBoundingBox,
    );
    guides.forEach(({ points, bisector }) => {
      const hl = Math.abs(points[0].x - points[1].x);
      const vl = Math.abs(points[0].y - points[1].y);
      if (hl === 0 && vl === 0) {
        return null;
      }
      guideLayer.appendChild(
        svg(
          "line",
          [
            attr("x1", points[0].x.toString()),
            attr("y1", points[0].y.toString()),
            attr("x2", points[1].x.toString()),
            attr("y2", points[1].y.toString()),
          ],
          [],
        ),
      );
      tooltipLayer === null || tooltipLayer === void 0
        ? void 0
        : tooltipLayer.show(
            roundTo(
              Math.max(hl, vl),
              __classPrivateFieldGet(this, _FrameCanvas_preferences, "f")
                .decimalPlaces,
            ).toString(10),
            hl > vl ? (points[0].x + points[1].x) * 0.5 : points[0].x,
            vl > hl ? (points[0].y + points[1].y) * 0.5 : points[0].y,
            hl > vl ? TooltipLayer.BOTTOM : TooltipLayer.RIGHT,
          );
      if (bisector) {
        guideLayer.appendChild(
          svg(
            "line",
            [
              attr("x1", bisector[0].x.toString()),
              attr("y1", bisector[0].y.toString()),
              attr("x2", bisector[1].x.toString()),
              attr("y2", bisector[1].y.toString()),
              style({
                "stroke-dasharray": "calc(4px / var(--_scale))",
              }),
              attr("shape-rendering", "geometricPrecision"),
            ],
            [],
          ),
        );
      }
    });
  }),
  (_FrameCanvas_focusIsInViewport = function _FrameCanvas_focusIsInViewport() {
    const shadowRoot = __classPrivateFieldGet(
      this,
      _FrameCanvas_container,
      "f",
    ).getRootNode();
    if (!(shadowRoot instanceof ShadowRoot)) {
      return false;
    }
    const activeElement = shadowRoot.activeElement;
    if (!activeElement) {
      return false;
    } else {
      return __classPrivateFieldGet(this, _FrameCanvas_container, "f").contains(
        activeElement,
      );
    }
  }),
  (_FrameCanvas_focusIsInShadowRoot =
    function _FrameCanvas_focusIsInShadowRoot() {
      const shadowRoot = __classPrivateFieldGet(
        this,
        _FrameCanvas_container,
        "f",
      ).getRootNode();
      if (!(shadowRoot instanceof ShadowRoot)) {
        return false;
      }
      return !!shadowRoot.activeElement;
    });
FrameCanvas.DRAG_MODE_KEY = " ";
/**
 * Returns distance between a first touch and center point of every touches.
 */
function getTouchAvgDist(touches) {
  let px = null;
  let py = null;
  let tx = 0;
  let ty = 0;
  for (let i = 0, touch; (touch = touches.item(i)); i++) {
    if (px === null || py === null) {
      px = touch.clientX;
      py = touch.clientY;
    }
    tx += touch.clientX;
    ty += touch.clientY;
  }
  const l = touches.length;
  if (px === null || py === null || !l) {
    return null;
  }
  const cx = tx / l;
  const cy = ty / l;
  return Math.sqrt(Math.pow(px - cx, 2) + Math.pow(py - cy, 2));
}
