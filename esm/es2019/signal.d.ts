declare const DEPENDANTS: unique symbol;
export declare class Signal<T> {
  private value;
  [DEPENDANTS]: Set<Computation>;
  constructor(value: T);
  set(value: T): void;
  /**
   * Get a current value of the signal.
   * This method updates dependency graph.
   */
  get(): T;
  /**
   * Get a current value of the signal.
   * This method does not update dependency graph.
   */
  once(): T;
}
type ComputationFn = () => void | (() => void);
declare class Computation {
  private fn;
  isDestroyed: boolean;
  childComputations: Set<Computation>;
  cleanup: ComputationFn | null;
  constructor(fn: ComputationFn);
  run(isolated?: boolean): void;
  runCleanup(): void;
  destroy(): void;
  destroyChildren(): void;
}
export declare function compute<T>(f: () => T): Signal<T>;
export declare function effect(f: ComputationFn): void;
export {};
