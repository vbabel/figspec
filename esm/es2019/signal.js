var _a;
const stack = [];
const DEPENDANTS = Symbol();
export class Signal {
  constructor(value) {
    this.value = value;
    this[_a] = new Set();
  }
  set(value) {
    if (value === this.value) {
      return;
    }
    for (const computation of this[DEPENDANTS]) {
      computation.runCleanup();
    }
    this.value = value;
    const dependantComputations = Array.from(this[DEPENDANTS]);
    this[DEPENDANTS].clear();
    for (const computation of dependantComputations) {
      if (computation.isDestroyed) {
        continue;
      }
      computation.run(true);
    }
  }
  /**
   * Get a current value of the signal.
   * This method updates dependency graph.
   */
  get() {
    if (stack.length > 0) {
      this[DEPENDANTS].add(stack[stack.length - 1]);
    }
    return this.value;
  }
  /**
   * Get a current value of the signal.
   * This method does not update dependency graph.
   */
  once() {
    return this.value;
  }
}
_a = DEPENDANTS;
class Computation {
  constructor(fn) {
    this.fn = fn;
    this.isDestroyed = false;
    this.childComputations = new Set();
    this.cleanup = null;
  }
  run(isolated = false) {
    var _b;
    this.runCleanup();
    this.destroyChildren();
    if (stack.length > 0 && !isolated) {
      stack[stack.length - 1].childComputations.add(this);
    }
    stack.push(this);
    try {
      this.cleanup = (_b = this.fn()) !== null && _b !== void 0 ? _b : null;
    } finally {
      stack.pop();
    }
  }
  runCleanup() {
    for (const child of this.childComputations) {
      child.runCleanup();
    }
    if (!this.cleanup) {
      return;
    }
    this.cleanup();
    this.cleanup = null;
  }
  destroy() {
    this.runCleanup();
    this.isDestroyed = true;
    this.destroyChildren();
  }
  destroyChildren() {
    for (const child of this.childComputations) {
      child.destroy();
    }
    this.childComputations.clear();
  }
}
export function compute(f) {
  const signal = new Signal(undefined);
  effect(() => {
    signal.set(f());
  });
  return signal;
}
export function effect(f) {
  new Computation(f).run();
}
